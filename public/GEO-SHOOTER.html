<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GEO-SHOOTER - Battle Arena</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #0a0e27, #1a1f3a);
        color: #fff;
        overflow: hidden;
      }

      h1 {
        margin: 15px 0;
        font-size: 2.5em;
        text-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
        letter-spacing: 2px;
      }

      #controls {
        margin-bottom: 10px;
        display: flex;
        gap: 15px;
        align-items: center;
        background: rgba(0, 0, 0, 0.5);
        padding: 15px 25px;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(255, 69, 0, 0.3);
      }

      input#room {
        padding: 10px 15px;
        border-radius: 8px;
        border: 2px solid #ff4500;
        outline: none;
        font-size: 1em;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        transition: all 0.3s;
      }

      input#room:focus {
        border-color: #ff6b35;
        box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
      }

      select#mapSelect {
        padding: 10px 15px;
        border-radius: 8px;
        border: 2px solid #ff4500;
        outline: none;
        font-size: 1em;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        cursor: pointer;
      }

      button#connectBtn {
        padding: 10px 20px;
        font-size: 1em;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: linear-gradient(135deg, #ff4500, #ff6b35);
        color: #fff;
        font-weight: bold;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
      }

      button#connectBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 69, 0, 0.6);
      }

      #status {
        font-weight: bold;
        font-size: 1.1em;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      #gameContainer {
        position: relative;
      }

      canvas {
        background: linear-gradient(180deg, #0a0e1a, #1a1f2e);
        border-radius: 15px;
        box-shadow: 0 0 50px rgba(255, 69, 0, 0.4), inset 0 0 50px rgba(0, 0, 0, 0.5);
        display: block;
      }

      #waitingScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: rgba(0, 0, 0, 0.8);
        padding: 40px 60px;
        border-radius: 20px;
        border: 3px solid #ff4500;
        box-shadow: 0 0 40px rgba(255, 69, 0, 0.6);
      }

      #waitingScreen h2 {
        font-size: 2em;
        margin-bottom: 20px;
        color: #ff6b35;
        text-shadow: 0 0 15px rgba(255, 69, 0, 0.8);
      }

      #waitingScreen p {
        font-size: 1.2em;
        margin: 10px 0;
      }

      .map-preview {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        justify-content: center;
      }

      .map-preview canvas {
        width: 80px;
        height: 50px;
        border: 2px solid #333;
        border-radius: 5px;
        cursor: pointer;
      }

      .map-preview canvas.active {
        border-color: #ff4500;
      }
    </style>
  </head>
  <body>
    <h1>‚öîÔ∏è GEO-SHOOTER</h1>

    <div id="controls">
      <input id="room" placeholder="Enter Room ID" value="war123" />
      <select id="mapSelect">
        <option value="arena">üèüÔ∏è Arena</option>
        <option value="maze">üåÄ Maze</option>
        <option value="fortress">üè∞ Fortress</option>
        <option value="chaos">üí• Chaos</option>
      </select>
      <button id="connectBtn">Connect</button>
      <span id="status">Not connected</span>
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>
      <div id="waitingScreen">
        <h2>‚è≥ Waiting for players...</h2>
        <p id="playerCount">0 players connected</p>
        <p id="readyStatus">Waiting for character selection</p>
        <p id="mapInfo" style="color: #ff6b35; margin-top: 10px;">Map: Arena</p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const waitingScreen = document.getElementById("waitingScreen");
      const playerCountEl = document.getElementById("playerCount");
      const readyStatusEl = document.getElementById("readyStatus");
      const mapInfoEl = document.getElementById("mapInfo");

      let ws, roomId;
      let gameState = "waiting"; // waiting, playing, ended
      let players = {}; // { playerId: { x, y, character, health, kills, deaths, lives, bullets, vx, vy, lastShot, ability } }
      let bullets = [];
      let obstacles = [];
      let camps = [];
      let specialZones = [];
      let powerUps = [];
      let currentMap = "arena";

      const MAX_LIVES = 3;
      const POWERUP_SPAWN_INTERVAL = 15000; // 15 seconds
      const POWERUP_DURATION = 10000; // 10 seconds on map

      // Character definitions with unique abilities
      const CHARACTERS = {
        TANK: {
          name: "Tank",
          color: "#4CAF50",
          stats: { speed: 2, health: 150, damage: 35, fireRate: 1.5, bulletSpeed: 8 },
          spider: { speed: 20, health: 95, damage: 70, fireRate: 35, defense: 80 },
          ability: {
            name: "Shield",
            icon: "üõ°Ô∏è",
            cooldown: 12000,
            duration: 3000,
            effect: "shield" // Absorbs all damage
          }
        },
        SNIPER: {
          name: "Sniper",
          color: "#2196F3",
          stats: { speed: 4, health: 80, damage: 60, fireRate: 2.5, bulletSpeed: 15 },
          spider: { speed: 70, health: 30, damage: 100, fireRate: 25, defense: 75 },
          ability: {
            name: "Piercing Shot",
            icon: "üéØ",
            cooldown: 10000,
            duration: 0,
            effect: "pierce" // Next shot goes through walls
          }
        },
        RUNNER: {
          name: "Runner",
          color: "#FFC107",
          stats: { speed: 7, health: 70, damage: 15, fireRate: 0.3, bulletSpeed: 10 },
          spider: { speed: 100, health: 40, damage: 30, fireRate: 100, defense: 30 },
          ability: {
            name: "Dash",
            icon: "üí®",
            cooldown: 6000,
            duration: 300,
            effect: "dash" // Super speed + invincibility
          }
        },
        BALANCED: {
          name: "Balanced",
          color: "#9C27B0",
          stats: { speed: 4.5, health: 100, damage: 25, fireRate: 0.8, bulletSpeed: 10 },
          spider: { speed: 60, health: 60, damage: 60, fireRate: 60, defense: 60 },
          ability: {
            name: "Heal Burst",
            icon: "üíö",
            cooldown: 15000,
            duration: 0,
            effect: "heal" // Instant heal 30%
          }
        },
        ASSAULT: {
          name: "Assault",
          color: "#FF5722",
          stats: { speed: 5, health: 90, damage: 30, fireRate: 0.5, bulletSpeed: 12 },
          spider: { speed: 70, health: 50, damage: 65, fireRate: 75, defense: 40 },
          ability: {
            name: "Triple Shot",
            icon: "üî•",
            cooldown: 8000,
            duration: 0,
            effect: "triple" // Fires 3 bullets in spread
          }
        }
      };

      // Map configurations
      const MAPS = {
        arena: {
          name: "Arena",
          background: "#0a0e1a",
          gridColor: "rgba(255, 255, 255, 0.05)",
          generateObstacles: () => {
            const obs = [];
            // Central structure
            obs.push({ x: canvas.width/2 - 75, y: canvas.height/2 - 75, w: 150, h: 150, color: "#37474F" });
            // Corner walls
            obs.push({ x: 200, y: 150, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 900, y: 150, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 200, y: 530, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 900, y: 530, w: 100, h: 20, color: "#37474F" });
            // Side walls
            obs.push({ x: 400, y: 250, w: 20, h: 100, color: "#37474F" });
            obs.push({ x: 780, y: 350, w: 20, h: 100, color: "#37474F" });
            return obs;
          },
          generateZones: () => [
          ]
        },
        maze: {
          name: "Maze",
          background: "#0d1117",
          gridColor: "rgba(100, 255, 100, 0.03)",
          generateObstacles: () => {
            const obs = [];
            // Horizontal walls
            for (let i = 0; i < 4; i++) {
              obs.push({ x: 150 + i * 250, y: 180, w: 150, h: 20, color: "#2d5a27" });
              obs.push({ x: 100 + i * 250, y: 500, w: 150, h: 20, color: "#2d5a27" });
            }
            // Vertical walls
            for (let i = 0; i < 3; i++) {
              obs.push({ x: 300 + i * 300, y: 250, w: 20, h: 200, color: "#2d5a27" });
            }
            return obs;
          },
          generateZones: () => [

          ]
        },
        fortress: {
          name: "Fortress",
          background: "#1a1510",
          gridColor: "rgba(255, 200, 100, 0.03)",
          generateObstacles: () => {
            const obs = [];
            // Outer walls
            obs.push({ x: 100, y: 100, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: canvas.width - 400, y: 100, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: 100, y: canvas.height - 130, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: canvas.width - 400, y: canvas.height - 130, w: 300, h: 30, color: "#5d4e37" });
            // Inner fortress
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 - 100, w: 200, h: 30, color: "#8b7355" });
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 + 70, w: 200, h: 30, color: "#8b7355" });
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 - 70, w: 30, h: 140, color: "#8b7355" });
            obs.push({ x: canvas.width/2 + 70, y: canvas.height/2 - 70, w: 30, h: 140, color: "#8b7355" });
            return obs;
          },
          generateZones: () => [

          ]
        },
        chaos: {
          name: "Chaos",
          background: "#1a0a0a",
          gridColor: "rgba(255, 50, 50, 0.03)",
          generateObstacles: () => {
            const obs = [];
            // Random procedural obstacles
            const seed = Date.now();
            const random = (i) => ((seed * (i + 1) * 9301 + 49297) % 233280) / 233280;
            
            for (let i = 0; i < 12; i++) {
              const x = 100 + random(i) * (canvas.width - 250);
              const y = 100 + random(i + 100) * (canvas.height - 250);
              const w = 40 + random(i + 200) * 80;
              const h = 20 + random(i + 300) * 60;
              
              // Avoid spawn corners
              if ((x < 200 && y < 200) || (x > canvas.width - 250 && y < 200) ||
                  (x < 200 && y > canvas.height - 250) || (x > canvas.width - 250 && y > canvas.height - 250)) {
                continue;
              }
              
              obs.push({ x, y, w, h, color: "#4a1a1a" });
            }
            return obs;
          },
          generateZones: () => {
            const zones = [];
            const types = ["speed", "damage", "heal", "slow"];
            for (let i = 0; i < 4; i++) {
              zones.push({
                x: 200 + i * 220,
                y: 300 + (i % 2) * 100,
                w: 60,
                h: 60,
                type: types[i],
                color: types[i] === "speed" ? "#00BCD4" : types[i] === "damage" ? "#F44336" : types[i] === "heal" ? "#4CAF50" : "#9E9E9E"
              });
            }
            return zones;
          }
        }
      };

      // Initialize environment based on map
      function initEnvironment(mapKey = "arena") {
        currentMap = mapKey;
        const map = MAPS[mapKey];
        
        obstacles = map.generateObstacles();
        specialZones = map.generateZones();
        
        // Healing camps in corners (always present)
        // Initialize empty camps array - will spawn randomly
        camps = [];
        
        powerUps = [];
        
        mapInfoEl.textContent = `Map: ${map.name}`;
      }

      // Spawn power-up for ability recharge
      // Drop types that can spawn
const DROP_TYPES = {
  ABILITY: {
    icon: "‚ö°",
    color: "#FFD700",
    effect: "recharge_ability",
    duration: 12000, // 12 seconds on map
    radius: 20
  },
  SPEED: {
    icon: "üí®",
    color: "#00BCD4", 
    effect: "speed_boost",
    duration: 10000,
    radius: 20,
    boostDuration: 5000 // How long the boost lasts
  },
  HEALTH: {
    icon: "‚ù§Ô∏è",
    color: "#4CAF50",
    effect: "heal",
    duration: 8000,
    radius: 20,
    healAmount: 30
  }
};

// Global event system
const ARENA_EVENTS = {
  INFERNO: {
    name: "Fire Tempest",
    icon: "üî•",
    duration: 15000, // Event lasts 15 seconds
    backgroundTint: 'rgba(255, 69, 0, 0.25)',
    wallColor: '#8B0000',
    gridColor: 'rgba(255, 100, 0, 0.15)'
  },
  BLIZZARD: {
    name: "Ice Blizzard", 
    icon: "‚ùÑÔ∏è",
    duration: 18000,
    backgroundTint: 'rgba(0, 191, 255, 0.2)',
    wallColor: '#4682B4',
    gridColor: 'rgba(200, 230, 255, 0.1)',
    particleColor: '#E0F7FF'
  },
  GRAVITY_CHAOS: {
    name: "Gravity Chaos",
    icon: "üåÄ",
    duration: 8000,
    backgroundTint: 'rgba(156, 39, 176, 0.2)',
    wallColor: '#7B1FA2',
    gridColor: 'rgba(200, 100, 255, 0.1)'
  }
};

let currentEvent = null;
let eventStartTime = 0;
let eventInterval = null;

// Track player-specific event states
// players[id].onFire = { startTime, wallX, wallY }
// players[id].frozen = { startTime, frozenUntil }

function startArenaEvents() {
  if (eventInterval) clearInterval(eventInterval);
  
  const scheduleNextEvent = () => {
    // Events happen after game has been running for a bit
    // Random interval: 25-40 seconds between events
    const delay = 25000 + Math.random() * 15000;
    
    setTimeout(() => {
      spawnArenaEvent();
      scheduleNextEvent();
    }, delay);
  };
  
  // First event after 30 seconds of gameplay
  setTimeout(() => {
    spawnArenaEvent();
    scheduleNextEvent();
  }, 30000);
}

function spawnArenaEvent() {
  if (gameState !== "playing") return;
  if (currentEvent) return; // One event at a time
  
  // Pick random event
  const eventKeys = Object.keys(ARENA_EVENTS);
  const randomKey = eventKeys[Math.floor(Math.random() * eventKeys.length)];
  const eventData = ARENA_EVENTS[randomKey];
  
  currentEvent = {
    type: randomKey,
    ...eventData
  };
  eventStartTime = Date.now();
  
  console.log(`üéÆ EVENT STARTED: ${eventData.name}`);
  
  // Notify all players
  ws.send(JSON.stringify({
    type: 'arena_event',
    event: randomKey,
    name: eventData.name,
    icon: eventData.icon,
    duration: eventData.duration
  }));
  
  // Auto-clear after duration
  setTimeout(() => {
    currentEvent = null;
    console.log('‚úÖ Event ended');
    
    // Notify phones event ended
    ws.send(JSON.stringify({
      type: 'arena_event_end'
    }));
  }, eventData.duration);
}

let activeDrops = [];

function spawnDrop() {
  if (gameState !== "playing") return;
  
  // Maximum 2 drops at once
  if (activeDrops.length >= 2) return;
  
  // Pick random drop type
  const dropKeys = Object.keys(DROP_TYPES);
  const randomKey = dropKeys[Math.floor(Math.random() * dropKeys.length)];
  const dropType = DROP_TYPES[randomKey];
  
  // Find safe spawn location
  let x, y, attempts = 0;
  do {
    x = 150 + Math.random() * (canvas.width - 300);
    y = 150 + Math.random() * (canvas.height - 300);
    attempts++;
  } while (attempts < 50 && isColliding(x, y, dropType.radius));
  
  activeDrops.push({
    type: randomKey,
    x, y,
    spawnTime: Date.now(),
    ...dropType
  });
  
  console.log(`Spawned ${randomKey} drop at (${x}, ${y})`);
}

// Natural drop rhythm: every 8-12 seconds
let dropInterval = null;
function startDropSpawning() {
  if (dropInterval) clearInterval(dropInterval);
  
  const scheduleNextDrop = () => {
    const delay = 8000 + Math.random() * 4000; // 8-12 seconds
    setTimeout(() => {
      spawnDrop();
      scheduleNextDrop();
    }, delay);
  };
  // Spawn one random healing pad
function spawnHealingPad() {
  if (gameState !== "playing") return;
  if (camps.length > 0) return; // Only one at a time
  
  const colors = ["#1565C0", "#C62828", "#2E7D32", "#F57C00"];
  const randomColor = colors[Math.floor(Math.random() * colors.length)];
  
  let x, y, attempts = 0;
  do {
    x = 100 + Math.random() * (canvas.width - 280);
    y = 100 + Math.random() * (canvas.height - 280);
    attempts++;
  } while (attempts < 50 && isColliding(x + 40, y + 40, 40));
  
  camps.push({
    x: x,
    y: y,
    w: 80,
    h: 80,
    color: randomColor,
    spawnTime: Date.now(),
    duration: 12000 // 12 seconds
  });
  
  console.log(`Spawned healing pad at (${x}, ${y})`);
}

// Start healing pad spawning
let healingPadInterval = null;
function startHealingPadSpawning() {
  if (healingPadInterval) clearInterval(healingPadInterval);
  
  const scheduleNextPad = () => {
    const delay = 10000 + Math.random() * 5000; // 10-15 seconds between pads
    setTimeout(() => {
      spawnHealingPad();
      scheduleNextPad();
    }, delay);
  };
  
  // First pad after 8 seconds
  setTimeout(() => {
    spawnHealingPad();
    scheduleNextPad();
  }, 8000);
}
  
  // First drop after 6 seconds
  setTimeout(() => {
    spawnDrop();
    scheduleNextDrop();
  }, 6000);
}

// Spawn one random healing pad
        function spawnHealingPad() {
          if (gameState !== "playing") return;
          if (camps.length > 0) return; // Only one at a time
          
          const colors = ["#1565C0", "#C62828", "#2E7D32", "#F57C00"];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];
          
          let x, y, attempts = 0;
          do {
            x = 100 + Math.random() * (canvas.width - 280);
            y = 100 + Math.random() * (canvas.height - 280);
            attempts++;
          } while (attempts < 50 && isColliding(x + 40, y + 40, 40));
          
          camps.push({
            x: x,
            y: y,
            w: 80,
            h: 80,
            color: randomColor,
            spawnTime: Date.now(),
            duration: 12000 // 12 seconds
          });
          
          console.log(`Spawned healing pad at (${x}, ${y})`);
        }

        // Start healing pad spawning
        let healingPadInterval = null;
        function startHealingPadSpawning() {
          if (healingPadInterval) clearInterval(healingPadInterval);
          
          const scheduleNextPad = () => {
            const delay = 10000 + Math.random() * 5000; // 10-15 seconds between pads
            setTimeout(() => {
              spawnHealingPad();
              scheduleNextPad();
            }, delay);
          };
          
          // First pad after 8 seconds
          setTimeout(() => {
            spawnHealingPad();
            scheduleNextPad();
          }, 8000);
        }

      function isColliding(x, y, r) {
        for (const obs of obstacles) {
          if (checkCollision({ x, y, r }, obs)) return true;
        }
        return false;
      }

      // Start power-up spawning // DA RIMUOVERE MI SA DIOCA
      let powerUpInterval = null;
      function startPowerUpSpawning() {
        if (powerUpInterval) clearInterval(powerUpInterval);
        powerUpInterval = setInterval(spawnPowerUp, POWERUP_SPAWN_INTERVAL);
        // Spawn first one after 5 seconds
        setTimeout(spawnPowerUp, 5000);
      }

      initEnvironment();

      // Map selection
      document.getElementById("mapSelect").onchange = (e) => {
        initEnvironment(e.target.value);
      };

      document.getElementById("connectBtn").onclick = () => {
        roomId = document.getElementById("room").value.trim() || "war123";
        currentMap = document.getElementById("mapSelect").value;
        
        const serverUrl =
          (window.location.protocol === "https:" ? "wss://" : "ws://") +
          window.location.host;

        ws = new WebSocket(serverUrl);

        ws.onopen = () => {
          ws.send(JSON.stringify({ type: "join", role: "pc", room: roomId, map: currentMap }));
          const status = document.getElementById("status");
          status.textContent = "Connected ‚úÖ";
          status.style.color = "#00ff88";
        };

        ws.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            handleServerMessage(data);
          } catch (err) {
            console.error("Error:", err);
          }
        };

        ws.onclose = () => {
          document.getElementById("status").textContent = "Disconnected ‚ùå";
          document.getElementById("status").style.color = "#ff4444";
          gameState = "waiting";
          waitingScreen.style.display = "block";
        };
      };

      function handleServerMessage(data) {
        switch (data.type) {
          case "player_joined":
            playerCountEl.textContent = `${data.totalPlayers} player${data.totalPlayers > 1 ? 's' : ''} connected`;
            break;

          case "character_selected":
            readyStatusEl.textContent = `${data.playerId.slice(-4)} selected ${data.character}`;
            break;

          case "game_start":
            gameState = "playing";
            waitingScreen.style.display = "none";
            initEnvironment(currentMap);
            startDropSpawning();
            startArenaEvents();
            startHealingPadSpawning();

            // Initialize players
            data.players.forEach((p, i) => {
              const spawnPoints = [
                { x: 100, y: 100 },
                { x: canvas.width - 100, y: 100 },
                { x: 100, y: canvas.height - 100 },
                { x: canvas.width - 100, y: canvas.height - 100 }
              ];
              const spawn = spawnPoints[i % 4];
              const char = CHARACTERS[p.character];

              players[p.id] = {
                id: p.id,
                x: spawn.x,
                y: spawn.y,
                vx: 0,
                vy: 0,
                r: 20,
                character: p.character,
                health: char.stats.health,
                maxHealth: char.stats.health,
                kills: 0,
                deaths: 0,
                lives: MAX_LIVES,
                lastShot: 0,
                lastHitBy: null,
                isRespawning: false,
                // Ability state
                abilityCooldown: 0,
                abilityActive: false,
                abilityEndTime: 0,
                pierceNextShot: false,
                dashDirection: { x: 0, y: 0 }
              };
            });

            // Notify phones that game started with map info
            ws.send(JSON.stringify({
              type: "game_update",
              players: Object.values(players).map(p => ({
                id: p.id,
                lives: p.lives,
                health: p.health,
                maxHealth: p.maxHealth,
                abilityCooldown: p.abilityCooldown,
                abilityActive: p.abilityActive
              }))
            }));
            break;

          case "player_move":
            if (players[data.playerId]) {
              const char = CHARACTERS[players[data.playerId].character];
              const player = players[data.playerId];
              let speedMod = 1;
              
              // Check speed boost from drops
              if (player.speedBoostEnd && Date.now() < player.speedBoostEnd) {
                speedMod = 2;
              }
              
              // Check if frozen
              if (player.frozen && player.frozen.canMove === false) {
                speedMod = 0; // Can't move!
              }
    
    // GRAVITY CHAOS: inversion handled on phone side
              
              // Dash ability
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "dash") {
                speedMod = 4;
              }
              
              players[data.playerId].vx = -data.ax * char.stats.speed * 0.15 * speedMod;
              players[data.playerId].vy = data.ay * char.stats.speed * 0.15 * speedMod;
            }
            break;

          case "player_shoot":
            if (players[data.playerId]) {
              shoot(data.playerId);
            }
            break;

          case "player_ability":
            if (players[data.playerId]) {
              activateAbility(data.playerId);
            }
            break;

                // ============ ADD THIS NEW CASE ============
    case "player_action":
      const player = players[data.playerId];
      if (!player) break;
      
      if (data.action === 'blow') {
        // Extinguish fire
        if (player.onFire) {
          delete player.onFire;
          
          ws.send(JSON.stringify({
            type: 'player_status',
            playerId: player.id,
            status: 'clear',
            message: '‚úÖ Fire extinguished!'
          }));
          
          console.log(`üí® Player ${player.id} extinguished fire`);
        }
      }
      
      if (data.action === 'shake') {
        // Break free from freeze
        if (player.frozen) {
          delete player.frozen;
          delete player.blizzardExposure;
          
          ws.send(JSON.stringify({
            type: 'player_status',
            playerId: player.id,
            status: 'clear',
            message: '‚úÖ Broke free from ice!'
          }));
          
          console.log(`üì± Player ${player.id} broke free from freeze`);
        }
      }
      break;
    // ============================================

          case "player_left":
            delete players[data.playerId];
            break;
        }
      }

      function activateAbility(playerId) {
        const player = players[playerId];
        if (!player || player.health <= 0) return;
        
        const char = CHARACTERS[player.character];
        const ability = char.ability;
        const now = Date.now();
        
        // Check cooldown
        if (now < player.abilityCooldown) return;
        
        // Set cooldown
        player.abilityCooldown = now + ability.cooldown;
        
        switch (ability.effect) {
          case "shield":
            player.abilityActive = true;
            player.abilityEndTime = now + ability.duration;
            break;
            
          case "pierce":
            player.pierceNextShot = true;
            player.abilityActive = true;
            player.abilityEndTime = now + 5000; // 5 seconds to use it
            break;
            
          case "dash":
            player.abilityActive = true;
            player.abilityEndTime = now + ability.duration;
            player.dashDirection = { x: player.vx, y: player.vy };
            break;
            
          case "heal":
            player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.3);
            break;
            
          case "triple":
            // Triple shot - fire 3 bullets with AUTO-AIM
            let tripleAngle = 0;
            
            // Find closest ALIVE enemy
            let tripleTarget = null;
            let tripleDist = Infinity;
            
            for (const enemy of Object.values(players)) {
              // Skip: self, dead, respawning, eliminated
              if (enemy.id === playerId) continue;
              if (enemy.health <= 0) continue;
              if (enemy.lives <= 0) continue;
              if (enemy.isRespawning) continue;
              
              const dx = enemy.x - player.x;
              const dy = enemy.y - player.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < tripleDist) {
                tripleDist = dist;
                tripleTarget = enemy;
              }
            }
            
            if (tripleTarget) {
              // Aim at enemy
              tripleAngle = Math.atan2(tripleTarget.y - player.y, tripleTarget.x - player.x);
            } else {
              // No enemy found - use movement direction or default to right
              if (Math.abs(player.vx) > 0.5 || Math.abs(player.vy) > 0.5) {
                tripleAngle = Math.atan2(player.vy, player.vx);
              } else {
                tripleAngle = 0; // Default: shoot right
              }
            }
            
            const spread = Math.PI / 8;
            
            for (let i = -1; i <= 1; i++) {
              const bulletAngle = tripleAngle + (i * spread);
              bullets.push({
                x: player.x + Math.cos(bulletAngle) * 30,
                y: player.y + Math.sin(bulletAngle) * 30,
                vx: Math.cos(bulletAngle) * char.stats.bulletSpeed,
                vy: Math.sin(bulletAngle) * char.stats.bulletSpeed,
                owner: playerId,
                damage: char.stats.damage,
                color: char.color,
                pierce: false
              });
            }
            break;
        }
        
        // Send update to player
        ws.send(JSON.stringify({
          type: "game_update",
          players: [{ id: playerId, abilityCooldown: player.abilityCooldown, abilityActive: player.abilityActive }]
        }));
      }

      function shoot(playerId) {
        const player = players[playerId];
        if (!player || player.health <= 0) return;

        const char = CHARACTERS[player.character];
        const now = Date.now();

        if (now - player.lastShot < char.stats.fireRate * 1000) return;
        player.lastShot = now;

        // AUTO-AIM: Find closest ALIVE enemy
        let closestEnemy = null;
        let closestDist = Infinity;
        
        for (const enemy of Object.values(players)) {
          // Skip: self, dead, respawning, eliminated
          if (enemy.id === playerId) continue;
          if (enemy.health <= 0) continue;
          if (enemy.lives <= 0) continue;
          if (enemy.isRespawning) continue;
          
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < closestDist) {
            closestDist = dist;
            closestEnemy = enemy;
          }
        }

        let dirX, dirY;
        
        if (closestEnemy) {
          // Aim at closest enemy
          const dx = closestEnemy.x - player.x;
          const dy = closestEnemy.y - player.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          dirX = dx / len;
          dirY = dy / len;
        } else {
          // No enemies found - use movement direction or default to right
          if (Math.abs(player.vx) > 0.5 || Math.abs(player.vy) > 0.5) {
            const len = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            dirX = player.vx / len;
            dirY = player.vy / len;
          } else {
            dirX = 1;
            dirY = 0;
          }
        }

        const isPiercing = player.pierceNextShot;
        if (isPiercing) {
          player.pierceNextShot = false;
          player.abilityActive = false;
        }

        bullets.push({
          x: player.x + dirX * 30,
          y: player.y + dirY * 30,
          vx: dirX * char.stats.bulletSpeed,
          vy: dirY * char.stats.bulletSpeed,
          owner: playerId,
          damage: char.stats.damage,
          color: char.color,
          pierce: isPiercing
        });
      }

      function isInZone(player, zone) {
        return player.x > zone.x && player.x < zone.x + zone.w &&
               player.y > zone.y && player.y < zone.y + zone.h;
      }

      function update() {
        if (gameState !== "playing") return;

        const now = Date.now();

        // Update power-ups (remove expired)
        powerUps = powerUps.filter(p => now - p.spawnTime < POWERUP_DURATION);

        // Update players
        Object.values(players).forEach(player => {
          // PRIMA: Check for death and respawn (deve essere processato anche se health <= 0)
          if (player.health <= 0 && player.lives > 0 && !player.isRespawning) {
            // Player just died - start respawn process
            player.isRespawning = true;
            player.lives--;
            player.deaths++;
            
            // Find killer and give kill credit
            if (player.lastHitBy && players[player.lastHitBy]) {
              players[player.lastHitBy].kills++;
            }

            // Send death update to all
            ws.send(JSON.stringify({
              type: "game_update",
              players: Object.values(players).map(p => ({
                id: p.id,
                lives: p.lives,
                health: p.health,
                maxHealth: p.maxHealth,
                kills: p.kills,
                deaths: p.deaths
              }))
            }));

            // Check if this player is eliminated (0 lives)
            if (player.lives <= 0) {
              player.isRespawning = false;
              checkGameEnd();
            } else {
              // Respawn after 3 seconds
              const playerId = player.id;
              setTimeout(() => {
                if (!players[playerId]) return;
                const p = players[playerId];
                
                const spawnPoints = [
                  { x: 100, y: 100 },
                  { x: canvas.width - 100, y: 100 },
                  { x: 100, y: canvas.height - 100 },
                  { x: canvas.width - 100, y: canvas.height - 100 }
                ];
                const spawn = spawnPoints[Math.floor(Math.random() * 4)];
                p.x = spawn.x;
                p.y = spawn.y;
                p.health = p.maxHealth;
                p.abilityActive = false;
                p.isRespawning = false;
                p.abilityCooldown = Date.now() + 2000;
                p.lastHitBy = null;
                
                // Notify respawn
                ws.send(JSON.stringify({
                  type: "game_update",
                  players: [{
                    id: p.id,
                    health: p.health,
                    maxHealth: p.maxHealth,
                    lives: p.lives
                  }]
                }));
              }, 3000);
            }
          }
          
          // Skip dead or eliminated players for movement/actions
          if (player.health <= 0 || player.lives <= 0) return;

          // Check ability expiration
          if (player.abilityActive && now > player.abilityEndTime) {
            player.abilityActive = false;
          }

          // Move
          const newX = player.x + player.vx;
          const newY = player.y + player.vy;

          // Collision with walls
          let canMoveX = true, canMoveY = true;

          for (const obs of obstacles) {
            if (checkCollision({ x: newX, y: player.y, r: player.r }, obs)) {
              canMoveX = false;
            }
            if (checkCollision({ x: player.x, y: newY, r: player.r }, obs)) {
              canMoveY = false;
            }
          }

          if (canMoveX) player.x = Math.max(player.r, Math.min(canvas.width - player.r, newX));
          if (canMoveY) player.y = Math.max(player.r, Math.min(canvas.height - player.r, newY));

          // Friction
          player.vx *= 0.92;
          player.vy *= 0.92;

          // ============ ARENA EVENT EFFECTS ============
if (currentEvent) {
  const eventAge = Date.now() - eventStartTime;
  
  if (currentEvent.type === 'INFERNO') {
    // Check if player touches walls while event is active
    let touchingWall = false;
    
    for (const obs of obstacles) {
      const closestX = Math.max(obs.x, Math.min(player.x, obs.x + obs.w));
      const closestY = Math.max(obs.y, Math.min(player.y, obs.y + obs.h));
      const dx = player.x - closestX;
      const dy = player.y - closestY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < player.r + 15) { // Close to wall
        touchingWall = true;
        break;
      }
    }
    
    if (touchingWall && !player.onFire) {
      // Catch fire!
      player.onFire = {
        startTime: Date.now(),
        damage: 8 // DPS
      };
      
      // Notify player
      ws.send(JSON.stringify({
        type: 'player_status',
        playerId: player.id,
        status: 'on_fire',
        message: 'üî• YOU ARE ON FIRE! BLOW TO EXTINGUISH!'
      }));
    }
  }
  
  if (currentEvent.type === 'BLIZZARD') {
    // Check if player is NOT protected by walls
    let protectedByWall = false;
    
    // Blizzard comes from the left side
    const blizzardOriginX = 0;
    const blizzardOriginY = canvas.height / 2;
    
    // Check if any wall blocks the blizzard path to player
    for (const obs of obstacles) {
      // Simple check: is obstacle between player and blizzard origin?
      if (obs.x < player.x && obs.x + obs.w > blizzardOriginX) {
        if (obs.y < player.y && obs.y + obs.h > player.y) {
          protectedByWall = true;
          break;
        }
      }
    }
    
    if (!protectedByWall) {
      // Exposed to blizzard
      if (!player.blizzardExposure) {
        player.blizzardExposure = 0;
      }
      player.blizzardExposure += 1;
      
      // After 3 seconds of exposure (180 frames), freeze
      if (player.blizzardExposure > 180 && !player.frozen) {
        player.frozen = {
          startTime: Date.now(),
          canMove: false
        };
        
        ws.send(JSON.stringify({
          type: 'player_status',
          playerId: player.id,
          status: 'frozen',
          message: '‚ùÑÔ∏è YOU ARE FROZEN! SHAKE TO BREAK FREE!'
        }));
      }
    } else {
      // Protected - slowly reduce exposure
      if (player.blizzardExposure) {
        player.blizzardExposure = Math.max(0, player.blizzardExposure - 2);
      }
    }
    
    // If frozen, can't move
    if (player.frozen && player.frozen.canMove === false) {
      player.vx = 0;
      player.vy = 0;
    }
  }
  
  if (currentEvent.type === 'GRAVITY_CHAOS') {
    // Controls are already inverted on phone side
    // No additional PC logic needed
  }
}

// Apply fire damage (persists even after event ends)
if (player.onFire) {
  player.health -= player.onFire.damage / 60; // Per frame
  
  // Visual indication needed
}

// Check if player speed boost is active
if (player.speedBoostEnd && Date.now() < player.speedBoostEnd) {
  // Speed boost active - handled in movement multiplier check
}

          // Camp healing
          // Camp healing - remove expired camps
          camps = camps.filter(camp => {
            const age = Date.now() - camp.spawnTime;
            if (age > camp.duration) return false; // Remove expired
            
            if (isInZone(player, camp)) {
              player.health = Math.min(player.maxHealth, player.health + 0.5);
            }
            return true;
          });

          // Special zone effects
          specialZones.forEach(zone => {
            if (isInZone(player, zone)) {
              switch (zone.type) {
                case "heal":
                  player.health = Math.min(player.maxHealth, player.health + 0.3);
                  break;
                case "damage":
                  if (!player.abilityActive || CHARACTERS[player.character].ability.effect !== "shield") {
                    player.health -= 0.2;
                  }
                  break;
              }
            }
          });

          // Power-up collection
// Drop collection
activeDrops = activeDrops.filter(drop => {
  const dx = player.x - drop.x;
  const dy = player.y - drop.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  
  if (dist < player.r + drop.radius) {
    // Apply drop effect
    switch (drop.effect) {
      case 'recharge_ability':
        player.abilityCooldown = 0;
        break;
      case 'speed_boost':
        player.speedBoostEnd = Date.now() + drop.boostDuration;
        break;
      case 'heal':
        player.health = Math.min(player.maxHealth, player.health + drop.healAmount);
        break;
    }
    
    // Notify player
    ws.send(JSON.stringify({
      type: 'game_update',
      players: [{ 
        id: player.id, 
        abilityCooldown: player.abilityCooldown,
        health: player.health,
        dropCollected: drop.type
      }]
    }));
    
    if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
    
    return false; // Remove drop
  }
  
  // Remove expired drops
  const age = Date.now() - drop.spawnTime;
  return age < drop.duration;
});
        });

        // Update bullets
        bullets = bullets.filter(bullet => {
          bullet.x += bullet.vx;
          bullet.y += bullet.vy;

          // Out of bounds
          if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            return false;
          }

          // Collision with obstacles (unless piercing)
          if (!bullet.pierce) {
            for (const obs of obstacles) {
              if (bullet.x > obs.x && bullet.x < obs.x + obs.w &&
                  bullet.y > obs.y && bullet.y < obs.y + obs.h) {
                return false;
              }
            }
          }

          // Collision with players
          for (let player of Object.values(players)) {
            // Skip: own bullets, dead players, respawning players, eliminated players
            if (player.id === bullet.owner || player.health <= 0 || player.isRespawning || player.lives <= 0) continue;

            const dx = bullet.x - player.x;
            const dy = bullet.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < player.r) {
              // Check for shield
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "shield") {
                // Blocked by shield
                return false;
              }
              
              // Check for dash invincibility
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "dash") {
                // Invincible during dash
                return false;
              }
              
              player.health -= bullet.damage;
              player.lastHitBy = bullet.owner;

              return false;
            }
          }

          return true;
        });

        // Check for game end periodically
        checkGameEnd();
      }

      function checkGameEnd() {
        if (gameState !== "playing") return;
        
        const alivePlayers = Object.values(players).filter(p => p.lives > 0);
        const totalPlayers = Object.keys(players).length;
        
        // Need at least 2 players to have started, and only 1 remaining
        if (totalPlayers > 1 && alivePlayers.length === 1) {
          gameState = "ended";
          const winner = alivePlayers[0];
          const winnerChar = CHARACTERS[winner.character];
          
          // Send game end to all phones
          ws.send(JSON.stringify({
            type: "game_end",
            winner: winner.id,
            character: winner.character,
            characterName: winnerChar.name,
            kills: winner.kills,
            deaths: winner.deaths
          }));
        }
        
        // Edge case: all players eliminated (draw)
        if (totalPlayers > 1 && alivePlayers.length === 0) {
          gameState = "ended";
          ws.send(JSON.stringify({
            type: "game_end",
            winner: null,
            character: null,
            isDraw: true
          }));
        }
      }

      function checkCollision(circle, rect) {
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        return (dx * dx + dy * dy) < (circle.r * circle.r);
      }

      function draw() {
        const map = MAPS[currentMap];
        
        // Clear with fade effect
        ctx.fillStyle = map.background + "4D";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = map.gridColor;
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 50) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }

        // Draw special zones
        specialZones.forEach(zone => {
          ctx.fillStyle = zone.color + "30";
          ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
          ctx.strokeStyle = zone.color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);
          ctx.setLineDash([]);

          // Draw zone icon
          ctx.font = "bold 24px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = zone.color;
          const icon = zone.type === "speed" ? "‚ö°" : zone.type === "damage" ? "‚ò†Ô∏è" : zone.type === "heal" ? "üíö" : "üêå";
          ctx.fillText(icon, zone.x + zone.w/2, zone.y + zone.h/2);
        });

        // Draw camps
        camps.forEach(camp => {
          ctx.fillStyle = camp.color + "40";
          ctx.fillRect(camp.x, camp.y, camp.w, camp.h);
          ctx.strokeStyle = camp.color;
          ctx.lineWidth = 3;
          ctx.strokeRect(camp.x, camp.y, camp.w, camp.h);

          ctx.fillStyle = camp.color;
          ctx.font = "bold 30px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("+", camp.x + camp.w / 2, camp.y + camp.h / 2);
        });

        // Draw obstacles
        // Draw obstacles
        obstacles.forEach(obs => {
          ctx.fillStyle = obs.color;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
          
          // Change border color during Inferno
          if (currentEvent && currentEvent.type === 'INFERNO') {
            ctx.strokeStyle = "#FF0000"; // Red border during fire event
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = "#546E7A"; // Normal grey border
            ctx.lineWidth = 2;
          }
          ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);

          // Texture
          ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
          for (let i = 0; i < 5; i++) {
            ctx.fillRect(obs.x + Math.random() * obs.w, obs.y + Math.random() * obs.h, 3, 3);
          }
        });

        // Draw power-ups
        // Draw drops
activeDrops.forEach(drop => {
  const age = Date.now() - drop.spawnTime;
  const pulse = 1 + Math.sin(age / 200) * 0.2;
  const alpha = age > drop.duration - 2000 ? Math.sin(age / 100) * 0.5 + 0.5 : 1;
  
  ctx.globalAlpha = alpha;
  
  // Glow
  ctx.shadowColor = drop.color;
  ctx.shadowBlur = 20;
  
  // Outer ring
  ctx.strokeStyle = drop.color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(drop.x, drop.y, drop.radius * pulse, 0, Math.PI * 2);
  ctx.stroke();
  
  // Inner fill
  ctx.fillStyle = drop.color + '60';
  ctx.beginPath();
  ctx.arc(drop.x, drop.y, drop.radius * pulse * 0.7, 0, Math.PI * 2);
  ctx.fill();
  
  // Icon
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(drop.icon, drop.x, drop.y);
  
  ctx.globalAlpha = 1;
});
ctx.shadowBlur = 0;

        // Draw bullets
        bullets.forEach(bullet => {
          ctx.fillStyle = bullet.color;
          ctx.shadowColor = bullet.color;
          ctx.shadowBlur = bullet.pierce ? 25 : 15;
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.pierce ? 8 : 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Piercing trail
          if (bullet.pierce) {
            ctx.strokeStyle = bullet.color + "60";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bullet.x - bullet.vx * 3, bullet.y - bullet.vy * 3);
            ctx.lineTo(bullet.x, bullet.y);
            ctx.stroke();
          }
        });
        ctx.shadowBlur = 0;

        // ============ EVENT VISUAL EFFECTS ============
if (currentEvent) {
  const map = MAPS[currentMap];
  
  // Background tint
  ctx.fillStyle = currentEvent.backgroundTint;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  if (currentEvent.type === 'INFERNO') {
    // Tint obstacles red
    obstacles.forEach(obs => {
      ctx.fillStyle = currentEvent.wallColor + '40';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
    });
    
    // Flame particles
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * canvas.width;
      const y = canvas.height - (Date.now() / 10 + i * 50) % canvas.height;
      const size = 5 + Math.random() * 10;
      
      ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, 0.6)`;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  if (currentEvent.type === 'BLIZZARD') {
    // Tint obstacles blue
    obstacles.forEach(obs => {
      ctx.fillStyle = currentEvent.wallColor + '40';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
    });
    
    // Snow particles from left
    for (let i = 0; i < 100; i++) {
      const windSpeed = 3;
      const x = ((Date.now() / 20) * windSpeed + i * 30) % (canvas.width + 100) - 100;
      const y = (i * 17) % canvas.height;
      
      ctx.fillStyle = currentEvent.particleColor;
      ctx.fillRect(x, y, 3, 8);
    }
  }
  
  if (currentEvent.type === 'GRAVITY_CHAOS') {
    // Distorted grid
    ctx.strokeStyle = currentEvent.gridColor;
    ctx.lineWidth = 2;
    const waveOffset = Math.sin(Date.now() / 200) * 20;
    
    for (let i = 0; i < canvas.width; i += 50) {
      ctx.beginPath();
      ctx.moveTo(i + waveOffset, 0);
      ctx.lineTo(i - waveOffset, canvas.height);
      ctx.stroke();
    }
    
    // Tint obstacles purple
    obstacles.forEach(obs => {
      ctx.fillStyle = currentEvent.wallColor + '30';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
    });
  }
  
  // Event timer bar at top
  const eventAge = Date.now() - eventStartTime;
  const timeLeft = currentEvent.duration - eventAge;
  const progress = timeLeft / currentEvent.duration;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
  ctx.fillRect(canvas.width/2 - 200, 10, 400, 30);
  
  ctx.fillStyle = '#ff4500';
  ctx.fillRect(canvas.width/2 - 195, 15, 390 * progress, 20);
  
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`${currentEvent.icon} ${currentEvent.name} - ${Math.ceil(timeLeft/1000)}s`, canvas.width/2, 28);
}

        // Draw players
        Object.values(players).forEach(player => {
          if (player.lives <= 0) {
            // Eliminated - show X
            ctx.fillStyle = "#666";
            ctx.font = "bold 40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("‚ùå", player.x, player.y);
            return;
          }
          
          if (player.health <= 0) {
            // Dead but has lives - tombstone
            ctx.fillStyle = "#424242";
            ctx.fillRect(player.x - 15, player.y - 10, 30, 35);
            ctx.fillStyle = "#616161";
            ctx.beginPath();
            ctx.arc(player.x, player.y - 10, 15, Math.PI, 0, false);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("üíÄ", player.x, player.y + 5);
            
            // Lives remaining
            ctx.fillStyle = "#ff4444";
            ctx.font = "12px Arial";
            ctx.fillText(`${player.lives} ‚ù§Ô∏è`, player.x, player.y + 30);
            return;
          }

          const char = CHARACTERS[player.character];
          const ability = char.ability;

          // Draw shadow
          ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
          ctx.beginPath();
          ctx.ellipse(player.x, player.y + player.r + 5, player.r, player.r * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();

          // Shield effect
          if (player.abilityActive && ability.effect === "shield") {
            ctx.strokeStyle = "#00ffff";
            ctx.lineWidth = 4;
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Dash effect
          if (player.abilityActive && ability.effect === "dash") {
            ctx.fillStyle = char.color + "40";
            for (let i = 1; i <= 3; i++) {
              ctx.beginPath();
              ctx.arc(player.x - player.vx * i * 5, player.y - player.vy * i * 5, player.r * (1 - i * 0.2), 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Piercing indicator
          if (player.pierceNextShot) {
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
          }

          // Fire effect
if (player.onFire) {
  for (let i = 0; i < 5; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = player.r + Math.random() * 10;
    const fx = player.x + Math.cos(angle) * dist;
    const fy = player.y + Math.sin(angle) * dist - Math.random() * 20;
    
    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${0.5 + Math.random() * 0.5})`;
    ctx.beginPath();
    ctx.arc(fx, fy, 3 + Math.random() * 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Frozen effect
if (player.frozen) {
  ctx.strokeStyle = '#00BFFF';
  ctx.lineWidth = 4;
  ctx.shadowColor = '#00BFFF';
  ctx.shadowBlur = 15;
  
  // Ice crystal shape
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(
      player.x + Math.cos(angle) * (player.r + 10),
      player.y + Math.sin(angle) * (player.r + 10)
    );
    ctx.stroke();
  }
  
  ctx.shadowBlur = 0;
}

          // Draw player shape
          ctx.fillStyle = char.color;
          ctx.shadowColor = char.color;
          ctx.shadowBlur = 20;
          ctx.beginPath();
          
          const r = player.r;
          const x = player.x;
          const y = player.y;
          
          if (player.character === 'TANK') {
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i - Math.PI / 2;
              const px = x + r * Math.cos(angle);
              const py = y + r * Math.sin(angle);
              i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
          } else if (player.character === 'SNIPER') {
            ctx.moveTo(x, y - r);
            ctx.lineTo(x + r * 0.9, y + r * 0.7);
            ctx.lineTo(x - r * 0.9, y + r * 0.7);
            ctx.closePath();
          } else if (player.character === 'RUNNER') {
            ctx.arc(x, y, r, 0, Math.PI * 2);
          } else if (player.character === 'BALANCED') {
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
              const px = x + r * Math.cos(angle);
              const py = y + r * Math.sin(angle);
              i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
          } else if (player.character === 'ASSAULT') {
            ctx.moveTo(x, y - r);
            ctx.lineTo(x + r, y);
            ctx.lineTo(x, y + r);
            ctx.lineTo(x - r, y);
            ctx.closePath();
          } else {
            ctx.arc(x, y, r, 0, Math.PI * 2);
          }
          
          ctx.fill();
          ctx.shadowBlur = 0;

          // Health bar
          const barWidth = 50;
          const barHeight = 6;
          const healthPercent = player.health / player.maxHealth;

          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth, barHeight);

          ctx.fillStyle = healthPercent > 0.6 ? "#4CAF50" : healthPercent > 0.3 ? "#FFC107" : "#F44336";
          ctx.fillRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth * healthPercent, barHeight);

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.strokeRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth, barHeight);

          // Lives display
          ctx.fillStyle = "#ff4444";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          let hearts = "";
          for (let i = 0; i < player.lives; i++) hearts += "‚ù§Ô∏è";
          ctx.fillText(hearts, player.x, player.y - player.r - 22);

          // Character name
          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px Arial";
          ctx.textBaseline = "bottom";
          ctx.fillText(char.name, player.x, player.y - player.r - 32);

          // Kill/death count
          ctx.fillStyle = "#FFD700";
          ctx.font = "10px Arial";
          ctx.fillText(`${player.kills}/${player.deaths}`, player.x, player.y + player.r + 15);

          // Ability cooldown indicator
          const cooldownRemaining = Math.max(0, player.abilityCooldown - Date.now());
          if (cooldownRemaining > 0) {
            const cooldownPercent = cooldownRemaining / ability.cooldown;
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.arc(player.x, player.y, player.r, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * cooldownPercent));
            ctx.closePath();
            ctx.fill();
          }
        });

        // Scoreboard (only during gameplay, not when game ended)
        if (gameState !== "ended") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(10, 10, 260, 50 + Object.keys(players).length * 25);

          ctx.fillStyle = "#FFD700";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.fillText("SCOREBOARD", 20, 15);
          ctx.fillStyle = "#888";
          ctx.font = "12px Arial";
          ctx.fillText(`Map: ${MAPS[currentMap].name}`, 120, 17);

          ctx.font = "14px Arial";
          let yPos = 45;
          Object.values(players)
            .sort((a, b) => b.kills - a.kills || a.deaths - b.deaths)
            .forEach((player, i) => {
              const char = CHARACTERS[player.character];
              const status = player.lives <= 0 ? " ‚ò†Ô∏è" : player.health <= 0 ? " üíÄ" : "";
              ctx.fillStyle = player.lives <= 0 ? "#666" : char.color;
              ctx.fillText(
                `${i + 1}. ${char.name}: ${player.kills}K/${player.deaths}D [${player.lives}‚ù§Ô∏è]${status}`,
                20, yPos
              );
              yPos += 25;
            });
        }

        // Game over screen
        if (gameState === "ended") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const winner = Object.values(players).find(p => p.lives > 0);
          const numPlayers = Object.keys(players).length;
          
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          
          if (winner) {
            const char = CHARACTERS[winner.character];
            
            // Trophy icon - positioned higher
            ctx.font = "60px Arial";
            ctx.fillText("üèÜ", canvas.width/2, 80);
            
            // Winner text with glow
            ctx.shadowColor = char.color;
            ctx.shadowBlur = 30;
            ctx.fillStyle = char.color;
            ctx.font = "bold 60px Arial";
            ctx.fillText("WINNER!", canvas.width/2, 160);
            ctx.shadowBlur = 0;
            
            // Character name
            ctx.fillStyle = "#fff";
            ctx.font = "bold 45px Arial";
            ctx.fillText(char.name, canvas.width/2, 230);
            
            // Stats
            ctx.fillStyle = "#FFD700";
            ctx.font = "24px Arial";
            ctx.fillText(`${winner.kills} Kills | ${winner.deaths} Deaths`, canvas.width/2, 280);
            
            // Draw winner shape with glow
            ctx.fillStyle = char.color;
            ctx.shadowColor = char.color;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(canvas.width/2, 340, 35, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          } else {
            // Draw - no winner
            ctx.fillStyle = "#ff6666";
            ctx.font = "bold 50px Arial";
            ctx.fillText("üíÄ DRAW! üíÄ", canvas.width/2, 150);
            ctx.fillStyle = "#aaa";
            ctx.font = "24px Arial";
            ctx.fillText("All players eliminated", canvas.width/2, 210);
          }
          
          // Final scoreboard - positioned below winner info
          const scoreboardY = winner ? 400 : 280;
          const scoreboardHeight = 40 + numPlayers * 28;
          
          ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
          ctx.fillRect(canvas.width/2 - 180, scoreboardY, 360, scoreboardHeight);
          
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 2;
          ctx.strokeRect(canvas.width/2 - 180, scoreboardY, 360, scoreboardHeight);
          
          ctx.fillStyle = "#fff";
          ctx.font = "bold 18px Arial";
          ctx.fillText("FINAL SCORES", canvas.width/2, scoreboardY + 22);
          
          ctx.font = "16px Arial";
          let finalY = scoreboardY + 50;
          Object.values(players)
            .sort((a, b) => b.kills - a.kills || a.deaths - b.deaths)
            .forEach((p, i) => {
              const c = CHARACTERS[p.character];
              ctx.fillStyle = p.lives > 0 ? c.color : "#888";
              const medal = i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : "  ";
              ctx.fillText(`${medal} ${c.name}: ${p.kills} Kills / ${p.deaths} Deaths`, canvas.width/2, finalY);
              finalY += 28;
            });
        }
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      loop();
    </script>
  </body>
</html>