<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GEO-SHOOTER - Battle Arena</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #0a0e27, #1a1f3a);
        color: #fff;
        overflow: hidden;
      }

      h1 {
        margin: 15px 0;
        font-size: 2.5em;
        text-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
        letter-spacing: 2px;
      }

      #controls {
        margin-bottom: 10px;
        display: flex;
        gap: 15px;
        align-items: center;
        background: rgba(0, 0, 0, 0.5);
        padding: 15px 25px;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(255, 69, 0, 0.3);
      }

      input#room {
        padding: 10px 15px;
        border-radius: 8px;
        border: 2px solid #ff4500;
        outline: none;
        font-size: 1em;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        transition: all 0.3s;
      }

      input#room:focus {
        border-color: #ff6b35;
        box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
      }

      select#mapSelect {
        padding: 10px 15px;
        border-radius: 8px;
        border: 2px solid #ff4500;
        outline: none;
        font-size: 1em;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        cursor: pointer;
      }

      button {
        padding: 10px 20px;
        font-size: 1em;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: linear-gradient(135deg, #ff4500, #ff6b35);
        color: #fff;
        font-weight: bold;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 69, 0, 0.6);
      }

      #audioControls {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      #volumeSlider {
        width: 80px;
      }

      #status {
        font-weight: bold;
        font-size: 1.1em;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      #gameContainer {
        position: relative;
      }

      canvas {
        background: linear-gradient(180deg, #0a0e1a, #1a1f2e);
        border-radius: 15px;
        box-shadow: 0 0 50px rgba(255, 69, 0, 0.4), inset 0 0 50px rgba(0, 0, 0, 0.5);
        display: block;
      }

      #waitingScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: rgba(0, 0, 0, 0.8);
        padding: 40px 60px;
        border-radius: 20px;
        border: 3px solid #ff4500;
        box-shadow: 0 0 40px rgba(255, 69, 0, 0.6);
      }

      #waitingScreen h2 {
        font-size: 2em;
        margin-bottom: 20px;
        color: #ff6b35;
        text-shadow: 0 0 15px rgba(255, 69, 0, 0.8);
      }

      #waitingScreen p {
        font-size: 1.2em;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <h1>‚öîÔ∏è GEO-SHOOTER</h1>

    <div id="controls">
      <input id="room" placeholder="Enter Room ID" value="war123" />
      <select id="mapSelect">
        <option value="arena">üèüÔ∏è Arena</option>
        <option value="maze">üåÄ Maze</option>
        <option value="fortress">üè∞ Fortress</option>
        <option value="chaos">üí• Chaos</option>
      </select>
      <button id="connectBtn">Connect</button>
      <div id="audioControls">
        <button id="muteBtn">üîä Mute</button>
        <input type="range" id="volumeSlider" min="0" max="100" value="70" />
      </div>
      <span id="status">Not connected</span>
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>
      <div id="waitingScreen">
        <h2>‚è≥ Waiting for players...</h2>
        <p id="playerCount">0 players connected</p>
        <p id="readyStatus">Waiting for character selection</p>
        <p id="mapInfo" style="color: #ff6b35; margin-top: 10px;">Map: Arena</p>
      </div>
    </div>

    <script>
      // ============ AUDIO SYSTEM ============
      class AudioManager {
        constructor() {
          this.sounds = {};
          this.bgMusic = null;
          this.isMuted = false;
          this.volume = 0.7;
          this.soundsLoaded = false;
        }

        async loadSounds() {
          const soundFiles = {
            bgMusic: 'sounds/bg-music.mp3',
            collectPowerup: 'sounds/collect-powerup.mp3',
            laserGunfire: 'sounds/laser-gunfire.mp3',
            moveOverItem: 'sounds/move-over-item.mp3',
            playerJoined: 'sounds/player-joined.mp3',
            playerRespawn: 'sounds/player-respawn.mp3',
            powerup: 'sounds/powerup.mp3'
          };

          for (const [key, path] of Object.entries(soundFiles)) {
            try {
              const audio = new Audio(path);
              audio.volume = this.volume;
              
              if (key === 'bgMusic') {
                audio.loop = true;
                this.bgMusic = audio;
              } else {
                this.sounds[key] = audio;
              }
            } catch (error) {
              console.warn(`Failed to load sound: ${path}`, error);
            }
          }

          this.soundsLoaded = true;
          console.log('üîä Audio system initialized');
        }

        play(soundName, options = {}) {
          if (this.isMuted || !this.soundsLoaded) return;

          const sound = this.sounds[soundName];
          if (!sound) {
            console.warn(`Sound not found: ${soundName}`);
            return;
          }

          // Clone audio for overlapping sounds
          const audioClone = sound.cloneNode();
          audioClone.volume = options.volume !== undefined ? options.volume * this.volume : this.volume;
          
          audioClone.play().catch(err => {
            console.warn(`Failed to play sound: ${soundName}`, err);
          });
        }

        playBgMusic() {
          if (this.isMuted || !this.bgMusic) return;
          
          this.bgMusic.volume = this.volume * 0.3; // Background music quieter
          this.bgMusic.play().catch(err => {
            console.warn('Failed to play background music', err);
          });
        }

        stopBgMusic() {
          if (this.bgMusic) {
            this.bgMusic.pause();
            this.bgMusic.currentTime = 0;
          }
        }

        setVolume(vol) {
          this.volume = vol;
          if (this.bgMusic) {
            this.bgMusic.volume = vol * 0.3;
          }
          Object.values(this.sounds).forEach(sound => {
            sound.volume = vol;
          });
        }

        toggleMute() {
          this.isMuted = !this.isMuted;
          
          if (this.isMuted) {
            this.stopBgMusic();
          } else {
            if (gameState === "playing") {
              this.playBgMusic();
            }
          }
          
          return this.isMuted;
        }
      }

      const audioManager = new AudioManager();

      // Audio controls
      document.getElementById('muteBtn').onclick = () => {
        const isMuted = audioManager.toggleMute();
        document.getElementById('muteBtn').textContent = isMuted ? 'üîá Unmute' : 'üîä Mute';
      };

      document.getElementById('volumeSlider').oninput = (e) => {
        audioManager.setVolume(e.target.value / 100);
      };

      // Load audio on page load
      audioManager.loadSounds();

      // ============ GAME CODE ============
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const waitingScreen = document.getElementById("waitingScreen");
      const playerCountEl = document.getElementById("playerCount");
      const readyStatusEl = document.getElementById("readyStatus");
      const mapInfoEl = document.getElementById("mapInfo");

      let ws, roomId;
      let gameState = "waiting";
      let players = {};
      let bullets = [];
      let obstacles = [];
      let camps = [];
      let specialZones = [];
      let powerUps = [];
      let currentMap = "arena";

      const MAX_LIVES = 3;

      const CHARACTERS = {
        TANK: {
          name: "Tank",
          color: "#4CAF50",
          stats: { speed: 2, health: 150, damage: 35, fireRate: 1.5, bulletSpeed: 8 },
          ability: {
            name: "Shield",
            icon: "üõ°Ô∏è",
            cooldown: 12000,
            duration: 3000,
            effect: "shield"
          }
        },
        SNIPER: {
          name: "Sniper",
          color: "#2196F3",
          stats: { speed: 4, health: 80, damage: 60, fireRate: 2.5, bulletSpeed: 15 },
          ability: {
            name: "Piercing Shot",
            icon: "üéØ",
            cooldown: 10000,
            duration: 0,
            effect: "pierce"
          }
        },
        RUNNER: {
          name: "Runner",
          color: "#FFC107",
          stats: { speed: 7, health: 70, damage: 15, fireRate: 0.3, bulletSpeed: 10 },
          ability: {
            name: "Dash",
            icon: "üí®",
            cooldown: 6000,
            duration: 300,
            effect: "dash"
          }
        },
        BALANCED: {
          name: "Balanced",
          color: "#9C27B0",
          stats: { speed: 4.5, health: 100, damage: 25, fireRate: 0.8, bulletSpeed: 10 },
          ability: {
            name: "Heal Burst",
            icon: "üíö",
            cooldown: 15000,
            duration: 0,
            effect: "heal"
          }
        },
        ASSAULT: {
          name: "Assault",
          color: "#FF5722",
          stats: { speed: 5, health: 90, damage: 30, fireRate: 0.5, bulletSpeed: 12 },
          ability: {
            name: "Triple Shot",
            icon: "üî•",
            cooldown: 8000,
            duration: 0,
            effect: "triple"
          }
        }
      };

      const MAPS = {
        arena: {
          name: "Arena",
          background: "#0a0e1a",
          gridColor: "rgba(255, 255, 255, 0.05)",
          generateObstacles: () => {
            const obs = [];
            obs.push({ x: canvas.width/2 - 75, y: canvas.height/2 - 75, w: 150, h: 150, color: "#37474F" });
            obs.push({ x: 200, y: 150, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 900, y: 150, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 200, y: 530, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 900, y: 530, w: 100, h: 20, color: "#37474F" });
            obs.push({ x: 400, y: 250, w: 20, h: 100, color: "#37474F" });
            obs.push({ x: 780, y: 350, w: 20, h: 100, color: "#37474F" });
            return obs;
          },
          generateZones: () => []
        },
        maze: {
          name: "Maze",
          background: "#0d1117",
          gridColor: "rgba(100, 255, 100, 0.03)",
          generateObstacles: () => {
            const obs = [];
            for (let i = 0; i < 4; i++) {
              obs.push({ x: 150 + i * 250, y: 180, w: 150, h: 20, color: "#2d5a27" });
              obs.push({ x: 100 + i * 250, y: 500, w: 150, h: 20, color: "#2d5a27" });
            }
            for (let i = 0; i < 3; i++) {
              obs.push({ x: 300 + i * 300, y: 250, w: 20, h: 200, color: "#2d5a27" });
            }
            return obs;
          },
          generateZones: () => []
        },
        fortress: {
          name: "Fortress",
          background: "#1a1510",
          gridColor: "rgba(255, 200, 100, 0.03)",
          generateObstacles: () => {
            const obs = [];
            obs.push({ x: 100, y: 100, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: canvas.width - 400, y: 100, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: 100, y: canvas.height - 130, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: canvas.width - 400, y: canvas.height - 130, w: 300, h: 30, color: "#5d4e37" });
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 - 100, w: 200, h: 30, color: "#8b7355" });
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 + 70, w: 200, h: 30, color: "#8b7355" });
            obs.push({ x: canvas.width/2 - 100, y: canvas.height/2 - 70, w: 30, h: 140, color: "#8b7355" });
            obs.push({ x: canvas.width/2 + 70, y: canvas.height/2 - 70, w: 30, h: 140, color: "#8b7355" });
            return obs;
          },
          generateZones: () => []
        },
        chaos: {
          name: "Chaos",
          background: "#1a0a0a",
          gridColor: "rgba(255, 50, 50, 0.03)",
          generateObstacles: () => {
            const obs = [];
            const seed = Date.now();
            const random = (i) => ((seed * (i + 1) * 9301 + 49297) % 233280) / 233280;
            
            for (let i = 0; i < 12; i++) {
              const x = 100 + random(i) * (canvas.width - 250);
              const y = 100 + random(i + 100) * (canvas.height - 250);
              const w = 40 + random(i + 200) * 80;
              const h = 20 + random(i + 300) * 60;
              
              if ((x < 200 && y < 200) || (x > canvas.width - 250 && y < 200) ||
                  (x < 200 && y > canvas.height - 250) || (x > canvas.width - 250 && y > canvas.height - 250)) {
                continue;
              }
              
              obs.push({ x, y, w, h, color: "#4a1a1a" });
            }
            return obs;
          },
          generateZones: () => []
        }
      };

      const DROP_TYPES = {
        ABILITY: {
          icon: "‚ö°",
          color: "#FFD700",
          effect: "recharge_ability",
          duration: 12000,
          radius: 20
        },
        SPEED: {
          icon: "üí®",
          color: "#00BCD4", 
          effect: "speed_boost",
          duration: 10000,
          radius: 20,
          boostDuration: 5000
        },
        HEALTH: {
          icon: "‚ù§Ô∏è",
          color: "#4CAF50",
          effect: "heal",
          duration: 8000,
          radius: 20,
          healAmount: 30
        }
      };

      const ARENA_EVENTS = {
        INFERNO: {
          name: "Fire Tempest",
          icon: "üî•",
          duration: 15000,
          backgroundTint: 'rgba(255, 69, 0, 0.25)',
          wallColor: '#8B0000',
          gridColor: 'rgba(255, 100, 0, 0.15)'
        },
        BLIZZARD: {
          name: "Ice Blizzard", 
          icon: "‚ùÑÔ∏è",
          duration: 18000,
          backgroundTint: 'rgba(0, 191, 255, 0.2)',
          wallColor: '#4682B4',
          gridColor: 'rgba(200, 230, 255, 0.1)',
          particleColor: '#E0F7FF'
        },
        GRAVITY_CHAOS: {
          name: "Gravity Chaos",
          icon: "üåÄ",
          duration: 8000,
          backgroundTint: 'rgba(156, 39, 176, 0.2)',
          wallColor: '#7B1FA2',
          gridColor: 'rgba(200, 100, 255, 0.1)'
        }
      };

      let currentEvent = null;
      let eventStartTime = 0;
      let activeDrops = [];
      let dropInterval = null;
      let healingPadInterval = null;

      function initEnvironment(mapKey = "arena") {
        currentMap = mapKey;
        const map = MAPS[mapKey];
        
        obstacles = map.generateObstacles();
        specialZones = map.generateZones();
        camps = [];
        activeDrops = [];
        
        mapInfoEl.textContent = `Map: ${map.name}`;
      }

      function spawnDrop() {
        if (gameState !== "playing") return;
        if (activeDrops.length >= 2) return;
        
        const dropKeys = Object.keys(DROP_TYPES);
        const randomKey = dropKeys[Math.floor(Math.random() * dropKeys.length)];
        const dropType = DROP_TYPES[randomKey];
        
        let x, y, attempts = 0;
        do {
          x = 150 + Math.random() * (canvas.width - 300);
          y = 150 + Math.random() * (canvas.height - 300);
          attempts++;
        } while (attempts < 50 && isColliding(x, y, dropType.radius));
        
        activeDrops.push({
          type: randomKey,
          x, y,
          spawnTime: Date.now(),
          ...dropType
        });
        
        // üîä SOUND: Powerup spawned
        audioManager.play('powerup', { volume: 0.4 });
      }

      function startDropSpawning() {
        if (dropInterval) clearInterval(dropInterval);
        
        const scheduleNextDrop = () => {
          const delay = 8000 + Math.random() * 4000;
          setTimeout(() => {
            spawnDrop();
            scheduleNextDrop();
          }, delay);
        };
        
        setTimeout(() => {
          spawnDrop();
          scheduleNextDrop();
        }, 6000);
      }

      function spawnHealingPad() {
        if (gameState !== "playing") return;
        if (camps.length > 0) return;
        
        const colors = ["#1565C0", "#C62828", "#2E7D32", "#F57C00"];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        
        let x, y, attempts = 0;
        do {
          x = 100 + Math.random() * (canvas.width - 280);
          y = 100 + Math.random() * (canvas.height - 280);
          attempts++;
        } while (attempts < 50 && isColliding(x + 40, y + 40, 40));
        
        camps.push({
          x: x,
          y: y,
          w: 80,
          h: 80,
          color: randomColor,
          spawnTime: Date.now(),
          duration: 12000
        });
        
        // üîä SOUND: Healing pad spawned
        audioManager.play('powerup', { volume: 0.3 });
      }

      function startHealingPadSpawning() {
        if (healingPadInterval) clearInterval(healingPadInterval);
        
        const scheduleNextPad = () => {
          const delay = 10000 + Math.random() * 5000;
          setTimeout(() => {
            spawnHealingPad();
            scheduleNextPad();
          }, delay);
        };
        
        setTimeout(() => {
          spawnHealingPad();
          scheduleNextPad();
        }, 8000);
      }

      function startArenaEvents() {
        const scheduleNextEvent = () => {
          const delay = 25000 + Math.random() * 15000;
          
          setTimeout(() => {
            spawnArenaEvent();
            scheduleNextEvent();
          }, delay);
        };
        
        setTimeout(() => {
          spawnArenaEvent();
          scheduleNextEvent();
        }, 30000);
      }

      function spawnArenaEvent() {
        if (gameState !== "playing") return;
        if (currentEvent) return;
        
        const eventKeys = Object.keys(ARENA_EVENTS);
        const randomKey = eventKeys[Math.floor(Math.random() * eventKeys.length)];
        const eventData = ARENA_EVENTS[randomKey];
        
        currentEvent = {
          type: randomKey,
          ...eventData
        };
        eventStartTime = Date.now();
        
        ws.send(JSON.stringify({
          type: 'arena_event',
          event: randomKey,
          name: eventData.name,
          icon: eventData.icon,
          duration: eventData.duration
        }));
        
        setTimeout(() => {
          currentEvent = null;
          ws.send(JSON.stringify({
            type: 'arena_event_end'
          }));
        }, eventData.duration);
      }

      function isColliding(x, y, r) {
        for (const obs of obstacles) {
          if (checkCollision({ x, y, r }, obs)) return true;
        }
        return false;
      }

      initEnvironment();

      document.getElementById("mapSelect").onchange = (e) => {
        initEnvironment(e.target.value);
      };

      document.getElementById("connectBtn").onclick = () => {
        roomId = document.getElementById("room").value.trim() || "war123";
        currentMap = document.getElementById("mapSelect").value;
        
        const serverUrl =
          (window.location.protocol === "https:" ? "wss://" : "ws://") +
          window.location.host;

        ws = new WebSocket(serverUrl);

        ws.onopen = () => {
          ws.send(JSON.stringify({ type: "join", role: "pc", room: roomId, map: currentMap }));
          const status = document.getElementById("status");
          status.textContent = "Connected ‚úÖ";
          status.style.color = "#00ff88";
        };

        ws.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            handleServerMessage(data);
          } catch (err) {
            console.error("Error:", err);
          }
        };

        ws.onclose = () => {
          document.getElementById("status").textContent = "Disconnected ‚ùå";
          document.getElementById("status").style.color = "#ff4444";
          gameState = "waiting";
          waitingScreen.style.display = "block";
          
          // üîä SOUND: Stop music on disconnect
          audioManager.stopBgMusic();
        };
      };

      function handleServerMessage(data) {
        switch (data.type) {
          case "player_joined":
            playerCountEl.textContent = `${data.totalPlayers} player${data.totalPlayers > 1 ? 's' : ''} connected`;
            // üîä SOUND: Player joined
            audioManager.play('playerJoined', { volume: 0.5 });
            break;

          case "character_selected":
            readyStatusEl.textContent = `${data.playerId.slice(-4)} selected ${data.character}`;
            break;

          case "game_start":
            gameState = "playing";
            waitingScreen.style.display = "none";
            initEnvironment(currentMap);
            startDropSpawning();
            startArenaEvents();
            startHealingPadSpawning();

            // üîä SOUND: Start background music
            audioManager.playBgMusic();

            data.players.forEach((p, i) => {
              const spawnPoints = [
                { x: 100, y: 100 },
                { x: canvas.width - 100, y: 100 },
                { x: 100, y: canvas.height - 100 },
                { x: canvas.width - 100, y: canvas.height - 100 }
              ];
              const spawn = spawnPoints[i % 4];
              const char = CHARACTERS[p.character];

              players[p.id] = {
                id: p.id,
                x: spawn.x,
                y: spawn.y,
                vx: 0,
                vy: 0,
                r: 20,
                character: p.character,
                health: char.stats.health,
                maxHealth: char.stats.health,
                kills: 0,
                deaths: 0,
                lives: MAX_LIVES,
                lastShot: 0,
                lastHitBy: null,
                isRespawning: false,
                abilityCooldown: 0,
                abilityActive: false,
                abilityEndTime: 0,
                pierceNextShot: false,
                dashDirection: { x: 0, y: 0 }
              };
            });

            ws.send(JSON.stringify({
              type: "game_update",
              players: Object.values(players).map(p => ({
                id: p.id,
                lives: p.lives,
                health: p.health,
                maxHealth: p.maxHealth,
                abilityCooldown: p.abilityCooldown,
                abilityActive: p.abilityActive
              }))
            }));
            break;

          case "player_move":
            if (players[data.playerId]) {
              const char = CHARACTERS[players[data.playerId].character];
              const player = players[data.playerId];
              let speedMod = 1;
              
              if (player.speedBoostEnd && Date.now() < player.speedBoostEnd) {
                speedMod = 2;
              }
              
              if (player.frozen && player.frozen.canMove === false) {
                speedMod = 0;
              }
              
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "dash") {
                speedMod = 4;
              }
              
              players[data.playerId].vx = -data.ax * char.stats.speed * 0.15 * speedMod;
              players[data.playerId].vy = data.ay * char.stats.speed * 0.15 * speedMod;
            }
            break;

          case "player_shoot":
            if (players[data.playerId]) {
              shoot(data.playerId);
            }
            break;

          case "player_ability":
            if (players[data.playerId]) {
              activateAbility(data.playerId);
            }
            break;

          case "player_action":
            const player = players[data.playerId];
            if (!player) break;
            
            if (data.action === 'blow') {
              if (player.onFire) {
                delete player.onFire;
                ws.send(JSON.stringify({
                  type: 'player_status',
                  playerId: player.id,
                  status: 'clear',
                  message: '‚úÖ Fire extinguished!'
                }));
              }
            }
            
            if (data.action === 'shake') {
              if (player.frozen) {
                delete player.frozen;
                delete player.blizzardExposure;
                ws.send(JSON.stringify({
                  type: 'player_status',
                  playerId: player.id,
                  status: 'clear',
                  message: '‚úÖ Broke free from ice!'
                }));
              }
            }
            break;

          case "player_left":
            delete players[data.playerId];
            break;
        }
      }

      function activateAbility(playerId) {
        const player = players[playerId];
        if (!player || player.health <= 0) return;
        
        const char = CHARACTERS[player.character];
        const ability = char.ability;
        const now = Date.now();
        
        if (now < player.abilityCooldown) return;
        
        player.abilityCooldown = now + ability.cooldown;
        
        switch (ability.effect) {
          case "shield":
            player.abilityActive = true;
            player.abilityEndTime = now + ability.duration;
            break;
            
          case "pierce":
            player.pierceNextShot = true;
            player.abilityActive = true;
            player.abilityEndTime = now + 5000;
            break;
            
          case "dash":
            player.abilityActive = true;
            player.abilityEndTime = now + ability.duration;
            player.dashDirection = { x: player.vx, y: player.vy };
            break;
            
          case "heal":
            player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.3);
            // üîä SOUND: Heal ability
            audioManager.play('collectPowerup', { volume: 0.6 });
            break;
            
          case "triple":
            let tripleAngle = 0;
            let tripleTarget = null;
            let tripleDist = Infinity;
            
            for (const enemy of Object.values(players)) {
              if (enemy.id === playerId) continue;
              if (enemy.health <= 0) continue;
              if (enemy.lives <= 0) continue;
              if (enemy.isRespawning) continue;
              
              const dx = enemy.x - player.x;
              const dy = enemy.y - player.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < tripleDist) {
                tripleDist = dist;
                tripleTarget = enemy;
              }
            }
            
            if (tripleTarget) {
              tripleAngle = Math.atan2(tripleTarget.y - player.y, tripleTarget.x - player.x);
            } else {
              if (Math.abs(player.vx) > 0.5 || Math.abs(player.vy) > 0.5) {
                tripleAngle = Math.atan2(player.vy, player.vx);
              } else {
                tripleAngle = 0;
              }
            }
            
            const spread = Math.PI / 8;
            
            for (let i = -1; i <= 1; i++) {
              const bulletAngle = tripleAngle + (i * spread);
              bullets.push({
                x: player.x + Math.cos(bulletAngle) * 30,
                y: player.y + Math.sin(bulletAngle) * 30,
                vx: Math.cos(bulletAngle) * char.stats.bulletSpeed,
                vy: Math.sin(bulletAngle) * char.stats.bulletSpeed,
                owner: playerId,
                damage: char.stats.damage,
                color: char.color,
                pierce: false
              });
            }
            
            // üîä SOUND: Triple shot
            audioManager.play('laserGunfire', { volume: 0.7 });
            break;
        }
        
        ws.send(JSON.stringify({
          type: "game_update",
          players: [{ id: playerId, abilityCooldown: player.abilityCooldown, abilityActive: player.abilityActive }]
        }));
      }

      function shoot(playerId) {
        const player = players[playerId];
        if (!player || player.health <= 0) return;

        const char = CHARACTERS[player.character];
        const now = Date.now();

        if (now - player.lastShot < char.stats.fireRate * 1000) return;
        player.lastShot = now;

        let closestEnemy = null;
        let closestDist = Infinity;
        
        for (const enemy of Object.values(players)) {
          if (enemy.id === playerId) continue;
          if (enemy.health <= 0) continue;
          if (enemy.lives <= 0) continue;
          if (enemy.isRespawning) continue;
          
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < closestDist) {
            closestDist = dist;
            closestEnemy = enemy;
          }
        }

        let dirX, dirY;
        
        if (closestEnemy) {
          const dx = closestEnemy.x - player.x;
          const dy = closestEnemy.y - player.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          dirX = dx / len;
          dirY = dy / len;
        } else {
          if (Math.abs(player.vx) > 0.5 || Math.abs(player.vy) > 0.5) {
            const len = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            dirX = player.vx / len;
            dirY = player.vy / len;
          } else {
            dirX = 1;
            dirY = 0;
          }
        }

        const isPiercing = player.pierceNextShot;
        if (isPiercing) {
          player.pierceNextShot = false;
          player.abilityActive = false;
        }

        bullets.push({
          x: player.x + dirX * 30,
          y: player.y + dirY * 30,
          vx: dirX * char.stats.bulletSpeed,
          vy: dirY * char.stats.bulletSpeed,
          owner: playerId,
          damage: char.stats.damage,
          color: char.color,
          pierce: isPiercing
        });

        // üîä SOUND: Laser gunfire
        audioManager.play('laserGunfire', { volume: 0.4 });
      }

      function isInZone(player, zone) {
        return player.x > zone.x && player.x < zone.x + zone.w &&
               player.y > zone.y && player.y < zone.y + zone.h;
      }

      function update() {
        if (gameState !== "playing") return;

        const now = Date.now();

        Object.values(players).forEach(player => {
          if (player.health <= 0 && player.lives > 0 && !player.isRespawning) {
            player.isRespawning = true;
            player.lives--;
            player.deaths++;
            
            if (player.lastHitBy && players[player.lastHitBy]) {
              players[player.lastHitBy].kills++;
            }

            ws.send(JSON.stringify({
              type: "game_update",
              players: Object.values(players).map(p => ({
                id: p.id,
                lives: p.lives,
                health: p.health,
                maxHealth: p.maxHealth,
                kills: p.kills,
                deaths: p.deaths
              }))
            }));

            if (player.lives <= 0) {
              player.isRespawning = false;
              checkGameEnd();
            } else {
              const playerId = player.id;
              setTimeout(() => {
                if (!players[playerId]) return;
                const p = players[playerId];
                
                const spawnPoints = [
                  { x: 100, y: 100 },
                  { x: canvas.width - 100, y: 100 },
                  { x: 100, y: canvas.height - 100 },
                  { x: canvas.width - 100, y: canvas.height - 100 }
                ];
                const spawn = spawnPoints[Math.floor(Math.random() * 4)];
                p.x = spawn.x;
                p.y = spawn.y;
                p.health = p.maxHealth;
                p.abilityActive = false;
                p.isRespawning = false;
                p.abilityCooldown = Date.now() + 2000;
                p.lastHitBy = null;
                
                // üîä SOUND: Player respawn
                audioManager.play('playerRespawn', { volume: 0.5 });
                
                ws.send(JSON.stringify({
                  type: "game_update",
                  players: [{
                    id: p.id,
                    health: p.health,
                    maxHealth: p.maxHealth,
                    lives: p.lives
                  }]
                }));
              }, 3000);
            }
          }
          
          if (player.health <= 0 || player.lives <= 0) return;

          if (player.abilityActive && now > player.abilityEndTime) {
            player.abilityActive = false;
          }

          const newX = player.x + player.vx;
          const newY = player.y + player.vy;

          let canMoveX = true, canMoveY = true;

          for (const obs of obstacles) {
            if (checkCollision({ x: newX, y: player.y, r: player.r }, obs)) {
              canMoveX = false;
            }
            if (checkCollision({ x: player.x, y: newY, r: player.r }, obs)) {
              canMoveY = false;
            }
          }

          if (canMoveX) player.x = Math.max(player.r, Math.min(canvas.width - player.r, newX));
          if (canMoveY) player.y = Math.max(player.r, Math.min(canvas.height - player.r, newY));

          player.vx *= 0.92;
          player.vy *= 0.92;

          if (currentEvent) {
            if (currentEvent.type === 'INFERNO') {
              let touchingWall = false;
              
              for (const obs of obstacles) {
                const closestX = Math.max(obs.x, Math.min(player.x, obs.x + obs.w));
                const closestY = Math.max(obs.y, Math.min(player.y, obs.y + obs.h));
                const dx = player.x - closestX;
                const dy = player.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.r + 15) {
                  touchingWall = true;
                  break;
                }
              }
              
              if (touchingWall && !player.onFire) {
                player.onFire = {
                  startTime: Date.now(),
                  damage: 8
                };
                
                ws.send(JSON.stringify({
                  type: 'player_status',
                  playerId: player.id,
                  status: 'on_fire',
                  message: 'üî• YOU ARE ON FIRE! BLOW TO EXTINGUISH!'
                }));
              }
            }
            
            if (currentEvent.type === 'BLIZZARD') {
              let protectedByWall = false;
              const blizzardOriginX = 0;
              const blizzardOriginY = canvas.height / 2;
              
              for (const obs of obstacles) {
                if (obs.x < player.x && obs.x + obs.w > blizzardOriginX) {
                  if (obs.y < player.y && obs.y + obs.h > player.y) {
                    protectedByWall = true;
                    break;
                  }
                }
              }
              
              if (!protectedByWall) {
                if (!player.blizzardExposure) {
                  player.blizzardExposure = 0;
                }
                player.blizzardExposure += 1;
                
                if (player.blizzardExposure > 180 && !player.frozen) {
                  player.frozen = {
                    startTime: Date.now(),
                    canMove: false
                  };
                  
                  ws.send(JSON.stringify({
                    type: 'player_status',
                    playerId: player.id,
                    status: 'frozen',
                    message: '‚ùÑÔ∏è YOU ARE FROZEN! SHAKE TO BREAK FREE!'
                  }));
                }
              } else {
                if (player.blizzardExposure) {
                  player.blizzardExposure = Math.max(0, player.blizzardExposure - 2);
                }
              }
              
              if (player.frozen && player.frozen.canMove === false) {
                player.vx = 0;
                player.vy = 0;
              }
            }
          }

          if (player.onFire) {
            player.health -= player.onFire.damage / 60;
          }

          camps = camps.filter(camp => {
            const age = Date.now() - camp.spawnTime;
            if (age > camp.duration) return false;
            
            if (isInZone(player, camp)) {
              player.health = Math.min(player.maxHealth, player.health + 0.5);
            }
            return true;
          });

          specialZones.forEach(zone => {
            if (isInZone(player, zone)) {
              switch (zone.type) {
                case "heal":
                  player.health = Math.min(player.maxHealth, player.health + 0.3);
                  break;
                case "damage":
                  if (!player.abilityActive || CHARACTERS[player.character].ability.effect !== "shield") {
                    player.health -= 0.2;
                  }
                  break;
              }
            }
          });

          activeDrops = activeDrops.filter(drop => {
            const dx = player.x - drop.x;
            const dy = player.y - drop.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < player.r + drop.radius) {
              switch (drop.effect) {
                case 'recharge_ability':
                  player.abilityCooldown = 0;
                  break;
                case 'speed_boost':
                  player.speedBoostEnd = Date.now() + drop.boostDuration;
                  break;
                case 'heal':
                  player.health = Math.min(player.maxHealth, player.health + drop.healAmount);
                  break;
              }
              
              // üîä SOUND: Collect powerup
              audioManager.play('collectPowerup', { volume: 0.6 });
              
              ws.send(JSON.stringify({
                type: 'game_update',
                players: [{ 
                  id: player.id, 
                  abilityCooldown: player.abilityCooldown,
                  health: player.health,
                  dropCollected: drop.type
                }]
              }));
              
              return false;
            }
            
            const age = Date.now() - drop.spawnTime;
            return age < drop.duration;
          });
        });

        bullets = bullets.filter(bullet => {
          bullet.x += bullet.vx;
          bullet.y += bullet.vy;

          if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            return false;
          }

          if (!bullet.pierce) {
            for (const obs of obstacles) {
              if (bullet.x > obs.x && bullet.x < obs.x + obs.w &&
                  bullet.y > obs.y && bullet.y < obs.y + obs.h) {
                return false;
              }
            }
          }

          for (let player of Object.values(players)) {
            if (player.id === bullet.owner || player.health <= 0 || player.isRespawning || player.lives <= 0) continue;

            const dx = bullet.x - player.x;
            const dy = bullet.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < player.r) {
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "shield") {
                return false;
              }
              
              if (player.abilityActive && CHARACTERS[player.character].ability.effect === "dash") {
                return false;
              }
              
              player.health -= bullet.damage;
              player.lastHitBy = bullet.owner;

              return false;
            }
          }

          return true;
        });

        checkGameEnd();
      }

      function checkGameEnd() {
        if (gameState !== "playing") return;
        
        const alivePlayers = Object.values(players).filter(p => p.lives > 0);
        const totalPlayers = Object.keys(players).length;
        
        if (totalPlayers > 1 && alivePlayers.length === 1) {
          gameState = "ended";
          const winner = alivePlayers[0];
          const winnerChar = CHARACTERS[winner.character];
          
          // üîä SOUND: Stop music on game end
          audioManager.stopBgMusic();
          
          ws.send(JSON.stringify({
            type: "game_end",
            winner: winner.id,
            character: winner.character,
            characterName: winnerChar.name,
            kills: winner.kills,
            deaths: winner.deaths
          }));
        }
        
        if (totalPlayers > 1 && alivePlayers.length === 0) {
          gameState = "ended";
          
          // üîä SOUND: Stop music
          audioManager.stopBgMusic();
          
          ws.send(JSON.stringify({
            type: "game_end",
            winner: null,
            character: null,
            isDraw: true
          }));
        }
      }

      function checkCollision(circle, rect) {
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        return (dx * dx + dy * dy) < (circle.r * circle.r);
      }

      function draw() {
        const map = MAPS[currentMap];
        
        ctx.fillStyle = map.background + "4D";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = map.gridColor;
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 50) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }

        specialZones.forEach(zone => {
          ctx.fillStyle = zone.color + "30";
          ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
          ctx.strokeStyle = zone.color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);
          ctx.setLineDash([]);

          ctx.font = "bold 24px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = zone.color;
          const icon = zone.type === "speed" ? "‚ö°" : zone.type === "damage" ? "‚ò†Ô∏è" : zone.type === "heal" ? "üíö" : "üåÄ";
          ctx.fillText(icon, zone.x + zone.w/2, zone.y + zone.h/2);
        });

        camps.forEach(camp => {
          ctx.fillStyle = camp.color + "40";
          ctx.fillRect(camp.x, camp.y, camp.w, camp.h);
          ctx.strokeStyle = camp.color;
          ctx.lineWidth = 3;
          ctx.strokeRect(camp.x, camp.y, camp.w, camp.h);

          ctx.fillStyle = camp.color;
          ctx.font = "bold 30px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("+", camp.x + camp.w / 2, camp.y + camp.h / 2);
        });

        obstacles.forEach(obs => {
          ctx.fillStyle = obs.color;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
          
          if (currentEvent && currentEvent.type === 'INFERNO') {
            ctx.strokeStyle = "#FF0000";
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = "#546E7A";
            ctx.lineWidth = 2;
          }
          ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);

          ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
          for (let i = 0; i < 5; i++) {
            ctx.fillRect(obs.x + Math.random() * obs.w, obs.y + Math.random() * obs.h, 3, 3);
          }
        });

        activeDrops.forEach(drop => {
          const age = Date.now() - drop.spawnTime;
          const pulse = 1 + Math.sin(age / 200) * 0.2;
          const alpha = age > drop.duration - 2000 ? Math.sin(age / 100) * 0.5 + 0.5 : 1;
          
          ctx.globalAlpha = alpha;
          ctx.shadowColor = drop.color;
          ctx.shadowBlur = 20;
          ctx.strokeStyle = drop.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(drop.x, drop.y, drop.radius * pulse, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.fillStyle = drop.color + '60';
          ctx.beginPath();
          ctx.arc(drop.x, drop.y, drop.radius * pulse * 0.7, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 20px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(drop.icon, drop.x, drop.y);
          
          ctx.globalAlpha = 1;
        });
        ctx.shadowBlur = 0;

        bullets.forEach(bullet => {
          ctx.fillStyle = bullet.color;
          ctx.shadowColor = bullet.color;
          ctx.shadowBlur = bullet.pierce ? 25 : 15;
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.pierce ? 8 : 5, 0, Math.PI * 2);
          ctx.fill();
          
          if (bullet.pierce) {
            ctx.strokeStyle = bullet.color + "60";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bullet.x - bullet.vx * 3, bullet.y - bullet.vy * 3);
            ctx.lineTo(bullet.x, bullet.y);
            ctx.stroke();
          }
        });
        ctx.shadowBlur = 0;

        if (currentEvent) {
          ctx.fillStyle = currentEvent.backgroundTint;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          if (currentEvent.type === 'INFERNO') {
            obstacles.forEach(obs => {
              ctx.fillStyle = currentEvent.wallColor + '40';
              ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            });
            
            for (let i = 0; i < 20; i++) {
              const x = Math.random() * canvas.width;
              const y = canvas.height - (Date.now() / 10 + i * 50) % canvas.height;
              const size = 5 + Math.random() * 10;
              
              ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, 0.6)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          if (currentEvent.type === 'BLIZZARD') {
            obstacles.forEach(obs => {
              ctx.fillStyle = currentEvent.wallColor + '40';
              ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            });
            
            for (let i = 0; i < 100; i++) {
              const windSpeed = 3;
              const x = ((Date.now() / 20) * windSpeed + i * 30) % (canvas.width + 100) - 100;
              const y = (i * 17) % canvas.height;
              
              ctx.fillStyle = currentEvent.particleColor;
              ctx.fillRect(x, y, 3, 8);
            }
          }
          
          if (currentEvent.type === 'GRAVITY_CHAOS') {
            ctx.strokeStyle = currentEvent.gridColor;
            ctx.lineWidth = 2;
            const waveOffset = Math.sin(Date.now() / 200) * 20;
            
            for (let i = 0; i < canvas.width; i += 50) {
              ctx.beginPath();
              ctx.moveTo(i + waveOffset, 0);
              ctx.lineTo(i - waveOffset, canvas.height);
              ctx.stroke();
            }
            
            obstacles.forEach(obs => {
              ctx.fillStyle = currentEvent.wallColor + '30';
              ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            });
          }
          
          const eventAge = Date.now() - eventStartTime;
          const timeLeft = currentEvent.duration - eventAge;
          const progress = timeLeft / currentEvent.duration;
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(canvas.width/2 - 200, 10, 400, 30);
          
          ctx.fillStyle = '#ff4500';
          ctx.fillRect(canvas.width/2 - 195, 15, 390 * progress, 20);
          
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`${currentEvent.icon} ${currentEvent.name} - ${Math.ceil(timeLeft/1000)}s`, canvas.width/2, 28);
        }

        Object.values(players).forEach(player => {
          if (player.lives <= 0) {
            ctx.fillStyle = "#666";
            ctx.font = "bold 40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("‚ùå", player.x, player.y);
            return;
          }
          
          if (player.health <= 0) {
            ctx.fillStyle = "#424242";
            ctx.fillRect(player.x - 15, player.y - 10, 30, 35);
            ctx.fillStyle = "#616161";
            ctx.beginPath();
            ctx.arc(player.x, player.y - 10, 15, Math.PI, 0, false);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("üíÄ", player.x, player.y + 5);
            
            ctx.fillStyle = "#ff4444";
            ctx.font = "12px Arial";
            ctx.fillText(`${player.lives} ‚ù§Ô∏è`, player.x, player.y + 30);
            return;
          }

          const char = CHARACTERS[player.character];
          const ability = char.ability;

          ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
          ctx.beginPath();
          ctx.ellipse(player.x, player.y + player.r + 5, player.r, player.r * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();

          if (player.abilityActive && ability.effect === "shield") {
            ctx.strokeStyle = "#00ffff";
            ctx.lineWidth = 4;
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          if (player.abilityActive && ability.effect === "dash") {
            ctx.fillStyle = char.color + "40";
            for (let i = 1; i <= 3; i++) {
              ctx.beginPath();
              ctx.arc(player.x - player.vx * i * 5, player.y - player.vy * i * 5, player.r * (1 - i * 0.2), 0, Math.PI * 2);
              ctx.fill();
            }
          }

          if (player.pierceNextShot) {
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
          }

          if (player.onFire) {
            for (let i = 0; i < 5; i++) {
              const angle = Math.random() * Math.PI * 2;
              const dist = player.r + Math.random() * 10;
              const fx = player.x + Math.cos(angle) * dist;
              const fy = player.y + Math.sin(angle) * dist - Math.random() * 20;
              
              ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${0.5 + Math.random() * 0.5})`;
              ctx.beginPath();
              ctx.arc(fx, fy, 3 + Math.random() * 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          if (player.frozen) {
            ctx.strokeStyle = '#00BFFF';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#00BFFF';
            ctx.shadowBlur = 15;
            
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              ctx.beginPath();
              ctx.moveTo(player.x, player.y);
              ctx.lineTo(
                player.x + Math.cos(angle) * (player.r + 10),
                player.y + Math.sin(angle) * (player.r + 10)
              );
              ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
          }

          ctx.fillStyle = char.color;
          ctx.shadowColor = char.color;
          ctx.shadowBlur = 20;
          ctx.beginPath();
          
          const r = player.r;
          const x = player.x;
          const y = player.y;
          
          if (player.character === 'TANK') {
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i - Math.PI / 2;
              const px = x + r * Math.cos(angle);
              const py = y + r * Math.sin(angle);
              i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
          } else if (player.character === 'SNIPER') {
            ctx.moveTo(x, y - r);
            ctx.lineTo(x + r * 0.9, y + r * 0.7);
            ctx.lineTo(x - r * 0.9, y + r * 0.7);
            ctx.closePath();
          } else if (player.character === 'RUNNER') {
            ctx.arc(x, y, r, 0, Math.PI * 2);
          } else if (player.character === 'BALANCED') {
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
              const px = x + r * Math.cos(angle);
              const py = y + r * Math.sin(angle);
              i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
          } else if (player.character === 'ASSAULT') {
            ctx.moveTo(x, y - r);
            ctx.lineTo(x + r, y);
            ctx.lineTo(x, y + r);
            ctx.lineTo(x - r, y);
            ctx.closePath();
          } else {
            ctx.arc(x, y, r, 0, Math.PI * 2);
          }
          
          ctx.fill();
          ctx.shadowBlur = 0;

          const barWidth = 50;
          const barHeight = 6;
          const healthPercent = player.health / player.maxHealth;

          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth, barHeight);

          ctx.fillStyle = healthPercent > 0.6 ? "#4CAF50" : healthPercent > 0.3 ? "#FFC107" : "#F44336";
          ctx.fillRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth * healthPercent, barHeight);

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.strokeRect(player.x - barWidth / 2, player.y - player.r - 15, barWidth, barHeight);

          ctx.fillStyle = "#ff4444";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          let hearts = "";
          for (let i = 0; i < player.lives; i++) hearts += "‚ù§Ô∏è";
          ctx.fillText(hearts, player.x, player.y - player.r - 22);

          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px Arial";
          ctx.textBaseline = "bottom";
          ctx.fillText(char.name, player.x, player.y - player.r - 32);

          ctx.fillStyle = "#FFD700";
          ctx.font = "10px Arial";
          ctx.fillText(`${player.kills}/${player.deaths}`, player.x, player.y + player.r + 15);

          const cooldownRemaining = Math.max(0, player.abilityCooldown - Date.now());
          if (cooldownRemaining > 0) {
            const cooldownPercent = cooldownRemaining / ability.cooldown;
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.arc(player.x, player.y, player.r, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * cooldownPercent));
            ctx.closePath();
            ctx.fill();
          }
        });

        if (gameState !== "ended") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(10, 10, 260, 50 + Object.keys(players).length * 25);

          ctx.fillStyle = "#FFD700";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.fillText("SCOREBOARD", 20, 15);
          ctx.fillStyle = "#888";
          ctx.font = "12px Arial";
          ctx.fillText(`Map: ${MAPS[currentMap].name}`, 120, 17);

          ctx.font = "14px Arial";
          let yPos = 45;
          Object.values(players)
            .sort((a, b) => b.kills - a.kills || a.deaths - b.deaths)
            .forEach((player, i) => {
              const char = CHARACTERS[player.character];
              const status = player.lives <= 0 ? " ‚ò†Ô∏è" : player.health <= 0 ? " üíÄ" : "";
              ctx.fillStyle = player.lives <= 0 ? "#666" : char.color;
              ctx.fillText(
                `${i + 1}. ${char.name}: ${player.kills}K/${player.deaths}D [${player.lives}‚ù§Ô∏è]${status}`,
                20, yPos
              );
              yPos += 25;
            });
        }

        if (gameState === "ended") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const winner = Object.values(players).find(p => p.lives > 0);
          const numPlayers = Object.keys(players).length;
          
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          
          if (winner) {
            const char = CHARACTERS[winner.character];
            
            ctx.font = "60px Arial";
            ctx.fillText("üèÜ", canvas.width/2, 80);
            
            ctx.shadowColor = char.color;
            ctx.shadowBlur = 30;
            ctx.fillStyle = char.color;
            ctx.font = "bold 60px Arial";
            ctx.fillText("WINNER!", canvas.width/2, 160);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = "#fff";
            ctx.font = "bold 45px Arial";
            ctx.fillText(char.name, canvas.width/2, 230);
            
            ctx.fillStyle = "#FFD700";
            ctx.font = "24px Arial";
            ctx.fillText(`${winner.kills} Kills | ${winner.deaths} Deaths`, canvas.width/2, 280);
            
            ctx.fillStyle = char.color;
            ctx.shadowColor = char.color;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(canvas.width/2, 340, 35, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          } else {
            ctx.fillStyle = "#ff6666";
            ctx.font = "bold 50px Arial";
            ctx.fillText("üíÄ DRAW! üíÄ", canvas.width/2, 150);
            ctx.fillStyle = "#aaa";
            ctx.font = "24px Arial";
            ctx.fillText("All players eliminated", canvas.width/2, 210);
          }
          
          const scoreboardY = winner ? 400 : 280;
          const scoreboardHeight = 40 + numPlayers * 28;
          
          ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
          ctx.fillRect(canvas.width/2 - 180, scoreboardY, 360, scoreboardHeight);
          
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 2;
          ctx.strokeRect(canvas.width/2 - 180, scoreboardY, 360, scoreboardHeight);
          
          ctx.fillStyle = "#fff";
          ctx.font = "bold 18px Arial";
          ctx.fillText("FINAL SCORES", canvas.width/2, scoreboardY + 22);
          
          ctx.font = "16px Arial";
          let finalY = scoreboardY + 50;
          Object.values(players)
            .sort((a, b) => b.kills - a.kills || a.deaths - b.deaths)
            .forEach((p, i) => {
              const c = CHARACTERS[p.character];
              ctx.fillStyle = p.lives > 0 ? c.color : "#888";
              const medal = i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : "  ";
              ctx.fillText(`${medal} ${c.name}: ${p.kills} Kills / ${p.deaths} Deaths`, canvas.width/2, finalY);
              finalY += 28;
            });
        }
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      loop();
    </script>
  </body>
</html>